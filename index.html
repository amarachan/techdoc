<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Technical Documentation</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Syne+Mono&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Ubuntu+Mono:wght@700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Architects+Daughter&family=Ubuntu+Mono:wght@700&display=swap"
        rel="stylesheet">
</head>
<nav id="navbar">
    <header>Python Documentation</header>
    <ul>
        <li><a href="#Introduction" class="nav-link">
                Introduction
            </a></li>
        <li><a href="#Prequsites and Using the Python Interpreter" class="nav-link">Prequsites and Using the Python Interpreter</a></li>
        <li><a href="#Argument Passing" class="nav-link"> Argument Passing</a></li>
        <li><a href="#Interactive Mode" class="nav-link">Interactive Mode</a></li>
        <li><a href="#Numbers" class="nav-link">Numbers</a></li>
        <li><a href="#Lists" class="nav-link">Lists</a></li>
        <li><a href="#if Statements" class="nav-link">if Statements</a></li>
        <li><a href="#for Statements" class="nav-link">for Statements</a></li>
        <li><a href="#The range() Function" class="nav-link">The range() Function</a></li>
        <li><a href="#pass Statements" class="nav-link">pass Statements</a></li>
        <li><a href="#Defining Functions" class="nav-link">Defining Functions</a></li>
        <li><a href="#Default Argument Values" class="nav-link">Default Argument Values</a></li>
        <li><a href="#Keyword Arguments" class="nav-link">Keyword Arguments</a></li>
        <li><a href="#Special parameters" class="nav-link">Special parameters</a></li>
        <li><a href="#Reference" class="nav-link">Reference</a></li>
    </ul>
</nav>
<main id="main-doc">
    <section class="main-section" id="Introduction">
        <header>Introduction</header>
        <p>Python is an easy to learn, powerful programming language. It has efficient high-level data structures
            and a simple but effective approach to object-oriented programming. Python’s elegant syntax and dynamic
            typing, together with its interpreted nature, make it an ideal language for scripting and rapid
            application development in many areas on most platforms.</p>
        <p>The Python interpreter and the extensive standard library are freely available in source or binary form for
            all major platforms from the Python Web site, https://www.python.org/, and may be freely distributed. The
            same site also contains distributions of and pointers to many free third party Python modules, programs and
            tools, and additional documentation.</p>
        <p>The Python interpreter is easily extended with new functions and data types implemented in C or C++ (or other
            languages callable from C). Python is also suitable as an extension language for customizable applications.
        </p>
    </section>

    <section class="main-section" id="Prequsites and Using the Python Interpreter">
        <header>Prequsites and Using the Python Interpreter</header>
        <p>A computer with any operating system like Linux (debian, redhat etc), windows, macos and python can
            downloaded and installed from <a href="https://www.python.org">www.python.org</a></p>
        <p><strong>Invoking the Interpreter</strong></p>
        <ul>
            <li>
                The Python interpreter is usually installed as /usr/local/bin/python3.9 on those machines where it is
                available; putting /usr/local/bin in your Unix shell’s search path makes it possible to start it by
                typing the command:python3
            </li>
            <li>to the shell. 1 Since the choice of the directory where the interpreter lives is an installation option,
                other places are possible; check with your local Python guru or system administrator. (E.g.,
                /usr/local/python is a popular alternative location.)</li>
            <li>On Windows machines where you have installed Python from the Microsoft Store, the python3.9 command will
                be available. If you have the py.exe launcher installed, you can use the py command. See Excursus:
                Setting environment variables for other ways to launch Python.</li>
            <li>Typing an end-of-file character (Control-D on Unix, Control-Z on Windows) at the primary prompt causes
                the interpreter to exit with a zero exit status. If that doesn’t work, you can exit the interpreter by
                typing the following command: quit().</li>
        </ul>


    </section>
    <section class="main-section" id="Argument Passing">
        <header>Argument Passing</header>
        <p>When known to the interpreter, the script name and additional arguments thereafter are turned into a list of
            strings and assigned to the argv variable in the sys module. You can access this list by executing import
            sys. The length of the list is at least one; when no script and no arguments are given, sys.argv[0] is an
            empty string. When the script name is given as '-' (meaning standard input), sys.argv[0] is set to '-'. When
            -c command is used, sys.argv[0] is set to '-c'. When -m module is used, sys.argv[0] is set to the full name
            of the located module. Options found after -c command or -m module are not consumed by the Python
            interpreter’s option processing but left in sys.argv for the command or module to handle.
        </p>
    </section>
    <section class="main-section" id="Interactive Mode">
        <header>Interactive Mode</header>
        <p>When commands are read from a tty, the interpreter is said to be in interactive mode. In this mode it prompts
            for the next command with the primary prompt, usually three greater-than signs (<span> <span> >>> </span>  </span>); for
            continuation lines
            it prompts with the secondary prompt, by default three dots (...). The interpreter prints a welcome message
            stating its version number and a copyright notice before printing the first prompt:</p>
        <code><span> $ </span> python3.9
            Python 3.9 (default, June 4 2019, 09:25:04)
            [GCC 4.8.2] on linux
            Type "help", "copyright", "credits" or "license" for more information.
            <br>
            <span> >>> </span> 
        </code>
        <p>As an example, take a look at this simple Hello World! program</p>
        <code>
            <span> >>> </span> print("Hello World!")
            <br>
            Hello World!
        </code>
    </section> <br>
    <section class="main-section" id="Numbers">
        <header>Numbers</header>
        <p>The interpreter acts as a simple calculator: you can type an expression at it and it will write the value.
            Expression syntax is straightforward: the operators +, -, * and / work just like in most other languages
            (for example, Pascal or C); parentheses (()) can be used for grouping. For example:</p>
        <code>
            <span> >>> </span> 2 + 2
            <br>
            4
            <br>
            <span> >>> </span> 50 - 5*6
            <br>
            20
            <br>
            <span> >>> </span> (50 - 5*6) / 4
            <br>
            5.0
            <br>
            <span> >>> </span> 8 / 5 # division always returns a floating point number
            <br>
            1.6

        </code>
        <p>The integer numbers (e.g. 2, 4, 20) have type int, the ones with a fractional part (e.g. 5.0, 1.6) have type
            float. We will see more about numeric types later in the tutorial.

            Division (/) always returns a float. To do floor division and get an integer result (discarding any
            fractional result) you can use the // operator; to calculate the remainder you can use %:
            <span> <span> >>> </span>  </span>

        </p>
        <code>

            <span> >>> </span> 17 / 3 # classic division returns a float
            <br>
            5.666666666666667
            <br>
            <span> >>> </span> 17 // 3 # floor division discards the fractional part
            <br>
            5
            <br>
            <span> >>> </span> 17 % 3 # the % operator returns the remainder of the division
            <br>
            2
            <br>
            <span> >>> </span> 5 * 3 + 2 # result * divisor + remainder
            <br>
            17
        </code>
        <p>With Python, it is possible to use the ** operator to calculate powers</p>
        <code>
            <span> >>> </span> width = 20 <br>
            <span> >>> </span> height = 5 * 9 <br>
            <span> >>> </span> width * height <br>
            900
        </code>
        <p>If a variable is not “defined” (assigned a value), trying to use it will give you an error:</p>
        <code>
            <span> >>> </span>  n # try to access an undefined variable
            <br>
            Traceback (most recent call last): <br>
            File <span>"&lt;stdin&gt;"</span>, line 1, in <span>&lt;module&gt;</span> <br>
            NameError: name 'n' is not defined <br>
        </code>
    </section>
    <br>
    <section class="main-section" id="Strings">
        <header>Strings</header>
        <p>Besides numbers, Python can also manipulate strings, which can be expressed in several ways. They can be
            enclosed in single quotes ('...') or double quotes ("...") with the same result 2. \ can be used to escape
            quotes:</p>
        <code>
            <span> >>> </span>  'spam eggs' # single quotes <br>
            'spam eggs' <br>
            <span> >>> </span>  'doesn\'t' # use \' to escape the single quote... <br>
            "doesn't" <br>
            <span> >>> </span>  "doesn't" # ...or use double quotes instead
            "doesn't" <br>
            <span> >>> </span>  '"Yes," they said.' <br>
            '"Yes," they said.'</code> <br>
    </section>
    <section class="main-section" id="Lists">
        <header>Lists</header>
        <p>Python knows a number of compound data types, used to group together other values. The most versatile is the
            list, which can be written as a list of comma-separated values (items) between square brackets. Lists might
            contain items of different types, but usually the items all have the same type.</p>
        <code>
            <span> >>> </span>  squares = [1, 4, 9, 16, 25] <br>
            <span> >>> </span>  squares <br>
            [1, 4, 9, 16, 25]
        </code>
        <p>Like strings (and all other built-in sequence types), lists can be indexed and sliced:</p>
        <code>
            <span> >>> </span>  squares[0] # indexing returns the item <br>
            1 <br>
            <span> >>> </span>  squares[-1] <br>
            25 <br>
            <span> >>> </span>  squares[-3:] # slicing returns a new list <br>
            [9, 16, 25]
        </code>
        <p>All slice operations return a new list containing the requested elements. This means that the following slice
            returns a shallow copy of the list:</p>
        <code>
            <span> >>> </span>  squares[:] <br>
            [1, 4, 9, 16, 25]
        </code>
        <p>Lists also support operations like concatenation:</p>
        <code>
            <span> >>> </span>  squares + [36, 49, 64, 81, 100] <br>
            [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
        </code>
        <p>Unlike strings, which are immutable, lists are a mutable type, i.e. it is possible to change their content:
        </p>
        <code>
            <span> >>> </span>  cubes = [1, 8, 27, 65, 125] # something's wrong here <br>
            <span> >>> </span>  4 ** 3 # the cube of 4 is 64, not 65! <br>
            64 <br>
            <span> >>> </span>  cubes[3] = 64 # replace the wrong value <br>
            <span> >>> </span>  cubes <br>
            [1, 8, 27, 64, 125]
        </code>
        <p>You can also add new items at the end of the list, by using the append() method (we will see more about
            methods later):</p>
        <code>
            <span> >>> </span>  cubes.append(216) # add the cube of 6 <br>
            <span> >>> </span>  cubes.append(7 ** 3) # and the cube of 7 <br>
            <span> >>> </span>  cubes <br>
            [1, 8, 27, 64, 125, 216, 343]
        </code>

    </section>
    <br>
    <section class="main-section" id="if Statements">
        <header>if Statements</header>
        <p>Perhaps the most well-known statement type is the if statement. For example:</p>
        <code>
            <span> >>> </span>  x = int(input("Please enter an integer: ")) <br>
            Please enter an integer: 42 <br>
            <span> >>> </span>  if x < 0: <br>
                ... &emsp;&emsp;&emsp;&emsp;x = 0 <br>
                ... &emsp;&emsp;&emsp;&emsp;print('Negative changed to zero') <br>
                ... elif x == 0: <br>
                ... &emsp;&emsp;&emsp;&emsp;print('Zero') <br>
                ... elif x == 1: <br>
                ... &emsp;&emsp;&emsp;&emsp;print('Single') <br>
                ... else: <br>
                ... &emsp;&emsp;&emsp;&emsp;print('More') <br>
                ... <br>
                so-on
        </code>
        <p>There can be zero or more elif parts, and the else part is optional. The keyword ‘elif’ is short for ‘else
            if’, and is useful to avoid excessive indentation. An if … elif … elif … sequence is a substitute for the
            switch or case statements found in other languages.</p>
    </section>

    <section class="main-section" id="for Statements">
        <header>for Statements</header>
        <p>The for statement in Python differs a bit from what you may be used to in C or Pascal. Rather than always
            iterating over an arithmetic progression of numbers (like in Pascal), or giving the user the ability to
            define both the iteration step and halting condition (as C), Python’s for statement iterates over the items
            of any sequence (a list or a string), in the order that they appear in the sequence. For example (no pun
            intended):</p>
        <code>
            <span> >>> </span>  # Measure some strings: <br>
            ... words = ['cat', 'window', 'defenestrate'] <br>
            <span> >>> </span>  for w in words: <br>
            ... print(w, len(w)) <br>
            ... <br>
            cat 3 <br>
            window 6 <br>
            defenestrate 12
        </code>

        <p>Code that modifies a collection while iterating over that same collection can be tricky to get right.
            Instead, it is usually more straight-forward to loop over a copy of the collection or to create a new
            collection:

        </p>
        <code>
            # Strategy: Iterate over a copy <br>
            for user, status in users.copy().items(): <br>
            &emsp;&emsp;&emsp;&emsp;if status == 'inactive': <br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;del users[user] <br>
            <br>
            # Strategy: Create a new collection <br>
            active_users = {} <br>
            for user, status in users.items(): <br>
            &emsp;&emsp;&emsp;&emsp;if status == 'active': <br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;active_users[user] = status
        </code>


    </section>
    <br>
    <section class="main-section" id="The range() Function">
        <header>The range() Function</header>
        <p>If you do need to iterate over a sequence of numbers, the built-in function range() comes in handy. It
            generates arithmetic progressions:</p>
        <code>
            <span> >>> </span>  for i in range(5): <br>
            ...&emsp;&emsp;&emsp;&emsp;print(i) <br>
            ... <br>
            0 <br>
            1 <br>
            2 <br>
            3 <br>
            4
        </code>
        <p>The given end point is never part of the generated sequence; range(10) generates 10 values, the legal indices
            for items of a sequence of length 10. It is possible to let the range start at another number, or to specify
            a different increment (even negative; sometimes this is called the ‘step’):</p>
        <code>
            range(5, 10) <br>
            &emsp;&emsp;&emsp;5, 6, 7, 8, 9 <br>

            range(0, 10, 3) <br>
            &emsp;&emsp;&emsp;0, 3, 6, 9 <br>
            <br>
            range(-10, -100, -30) <br>
            &emsp;&emsp;&emsp;-10, -40, -70
        </code>
        <p>To iterate over the indices of a sequence, you can combine range() and len() as follows:</p>
        <code>
            <span> >>> </span>  a = ['Mary', 'had', 'a', 'little', 'lamb']
            <span> >>> </span>  for i in range(len(a)): <br>
            ...&emsp;&emsp;&emsp;&emsp;print(i, a[i]) <br>
            ... <br>
            0 Maya <br>
            1 had <br>
            2 a <br>
            3 little <br>
            4 doll
        </code>
        <p>In most such cases, however, it is convenient to use the enumerate() function, see Looping Techniques.
            <br>
            A strange thing happens if you just print a range:</p>

        <code>
            <span> >>> </span>  print(range(10)) <br>
            range(0, 10)
        </code>
        <p>In many ways the object returned by range() behaves as if it is a list, but in fact it isn’t. It is an object
            which returns the successive items of the desired sequence when you iterate over it, but it doesn’t really
            make the list, thus saving space.</p>
        <p>We say such an object is iterable, that is, suitable as a target for functions and constructs that expect
            something from which they can obtain successive items until the supply is exhausted. We have seen that the
            for statement is such a construct, while an example of a function that takes an iterable is sum():</p>
        <code>
            <span> >>> </span>  sum(range(4)) # 0 + 1 + 2 + 3
            <br> 6</code>
         <p>Later we will see more functions that return iterables and take iterables as arguments. Lastly, maybe you are curious about how to get a list from a range. Here is the solution:</p>   
            <code>
                <span> >>> </span>  list(range(4))
<br> [0, 1, 2, 3]

            </code>


        </section>
<br>
    <section class="main-section" id="break and continue Statements, and else Clauses on Loops">
        <header>break and continue Statements, and else Clauses on Loops

        </header>

        <p>The break statement, like in C, breaks out of the innermost enclosing for or while loop.</p>
<p>Loop statements may have an else clause; it is executed when the loop terminates through exhaustion of the iterable (with for) or when the condition becomes false (with while), but not when the loop is terminated by a break statement. This is exemplified by the following loop, which searches for prime numbers:</p>
<code>
    <span> >>> </span>  for n in range(2, 10):
    ... &emsp;&emsp;&emsp;&emsp;for x in range(2, n):
    ... &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;if n % x == 0: <br>
    ... &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;print(n, 'equals', x, '*', n//x)
  <br>  ... &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;break <br>
    ... &emsp;&emsp;&emsp;&emsp;else: <br>
   <br> ...         # loop fell through without finding a factor
   <br> ... &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;print(n, 'is a prime number')
    ... <br>
    2 is a prime number <br>
    3 is a prime number <br>
    4 equals 2 * 2 <br>
    5 is a prime number <br>
    6 equals 2 * 3 <br>
    7 is a prime number <br>
    8 equals 2 * 4 <br>
    9 equals 3 * 3 
</code>

<p>(Yes, this is the correct code. Look closely: the else clause belongs to the for loop, not the if statement.)</p>
<p>When used with a loop, the else clause has more in common with the else clause of a try statement than it does with that of if statements: a try statement’s else clause runs when no exception occurs, and a loop’s else clause runs when no break occurs. For more on the try statement and exceptions, see Handling Exceptions.</p>
<p>The continue statement, also borrowed from C, continues with the next iteration of the loop:</p>
<code>
    <span> >>> </span>  for num in range(2, 10): <br>
...&emsp;&emsp;&emsp;&emsp;if num % 2 == 0: <br>
...&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;print("Found an even number", num) <br>
...&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;continue <br>
...&emsp;&emsp;&emsp;&emsp;print("Found an odd number", num) <br>
Found an even number 2 <br>
Found an odd number 3 <br>
Found an even number 4 <br>
Found an odd number 5 <br>
Found an even number 6 <br>
Found an odd number 7 <br>
Found an even number 8 <br>
Found an odd number 9 
</code>




    </section>
    <section class="main-section" id="pass Statements">
        <header>pass Statements</header>
        <p>The pass statement does nothing. It can be used when a statement is required syntactically but the program requires no action. For example:</p>

        <code>
            <span> >>> </span>  while True:
...&emsp;&emsp;&emsp;&emsp;pass  # Busy-wait for keyboard interrupt (Ctrl+C)
...
        </code>
<p>This is commonly used for creating minimal classes:</p>
<code>
    <span> >>> </span>  class MyEmptyClass:
...&emsp;&emsp;&emsp;&emsp;pass
...
</code>
<p>Another place pass can be used is as a place-holder for a function or conditional body when you are working on new code, allowing you to keep thinking at a more abstract level. The pass is silently ignored:</p>

<code>
    <span> >>> </span>  def initlog(*args):
...&emsp;&emsp;&emsp;&emsp;pass   # Remember to implement this!
...
</code>



    </section>
   <br>

    <section class="main-section" id="Defining Functions">
        <header>Defining Functions</header>

        <p>We can create a function that writes the Fibonacci series to an arbitrary boundary:</p>

        <code>
            <span> >>> </span>  def fib(n):    # write Fibonacci series up to n 
<br>...&emsp;&emsp;&emsp;&emsp;"""Print a Fibonacci series up to n.""" <br>
...&emsp;&emsp;&emsp;&emsp;a, b = 0, 1 <br>
...&emsp;&emsp;&emsp;&emsp;while a < n: <br>
...&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;print(a, end=' ') <br>
...&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;a, b = b, a+b <br>
...&emsp;&emsp;&emsp;&emsp;print() <br>
... <br>
<span> >>> </span>  # Now call the function we just defined: <br>
... fib(2000) <br>
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
        </code>
<p>The keyword def introduces a function definition. It must be followed by the function name and the parenthesized list of formal parameters. The statements that form the body of the function start at the next line, and must be indented.</p>
<p>The first statement of the function body can optionally be a string literal; this string literal is the function’s documentation string, or docstring. (More about docstrings can be found in the section Documentation Strings.) There are tools which use docstrings to automatically produce online or printed documentation, or to let the user interactively browse through code; it’s good practice to include docstrings in code that you write, so make a habit of it.</p>
<p>The execution of a function introduces a new symbol table used for the local variables of the function. More precisely, all variable assignments in a function store the value in the local symbol table; whereas variable references first look in the local symbol table, then in the local symbol tables of enclosing functions, then in the global symbol table, and finally in the table of built-in names. Thus, global variables and variables of enclosing functions cannot be directly assigned a value within a function (unless, for global variables, named in a global statement, or, for variables of enclosing functions, named in a nonlocal statement), although they may be referenced.</p>
<p>The actual parameters (arguments) to a function call are introduced in the local symbol table of the called function when it is called; thus, arguments are passed using call by value (where the value is always an object reference, not the value of the object). 1 When a function calls another function, a new local symbol table is created for that call.</p>
<p>A function definition associates the function name with the function object in the current symbol table. The interpreter recognizes the object pointed to by that name as a user-defined function. Other names can also point to that same function object and can also be used to access the function:</p>
<code>
    <span> >>> </span>  fib <br>
<function fib at 10042ed0> <br>
<span> >>> </span>  f = fib <br>
<span> >>> </span>  f(100) <br>
0 1 1 2 3 5 8 13 21 34 55 89
</code>
<p>Coming from other languages, you might object that fib is not a function but a procedure since it doesn’t return a value. In fact, even functions without a return statement do return a value, albeit a rather boring one. This value is called None (it’s a built-in name). Writing the value None is normally suppressed by the interpreter if it would be the only value written. You can see it if you really want to using print():</p>


    </section>

    <section class="main-section">
        <header>Default Argument Values</header>
        <p>The most useful form is to specify a default value for one or more arguments. This creates a function that can be called with fewer arguments than it is defined to allow. For example:</p>
        <code>
            def ask_ok(prompt, retries=4, reminder='Please try again!'): <br>
            &emsp;&emsp;&emsp;&emsp;while True: <br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;ok = input(prompt) <br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;if ok in ('y', 'ye', 'yes'): <br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return True <br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;if ok in ('n', 'no', 'nop', 'nope'): <br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;return False <br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;retries = retries - 1 <br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;if retries &lt; 0: <br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;raise ValueError('invalid user response') <br>
            &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;print(reminder)
        </code>
        <p><strong>This function can be called in several ways:</strong></p>
        <ul>
            <li>giving only the mandatory argument: ask_ok('Do you really want to quit?')</li>
            <li>giving one of the optional arguments: ask_ok('OK to overwrite the file?', 2)</li>
            <li>or even giving all arguments: ask_ok('OK to overwrite the file?', 2, 'Come on, only yes or no!')</li>
        </ul>
    </section>
    <section class="main-section">
        <header>Keyword Arguments</header>
        <p>Functions can also be called using keyword arguments of the form kwarg=value. For instance, the following function:</p>
        <code>
            def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
            &emsp;&emsp;&emsp;&emsp;print("-- This parrot wouldn't", action, end=' ')
            &emsp;&emsp;&emsp;&emsp;print("if you put", voltage, "volts through it.")
            &emsp;&emsp;&emsp;&emsp;print("-- Lovely plumage, the", type)
            &emsp;&emsp;&emsp;&emsp;print("-- It's", state, "!")
        </code>
        <p>accepts one required argument (voltage) and three optional arguments (state, action, and type). This function can be called in any of the following ways:</p>
        <code>


parrot(1000)                                          # 1 positional argument <br>
parrot(voltage=1000)                                  # 1 keyword argument <br>
parrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments <br>
parrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments <br>
parrot('a million', 'bereft of life', 'jump')         # 3 positional arguments <br>
parrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 keyword


        </code>
<p>but all the following calls would be invalid:</p>

<code>
    parrot()                     # required argument missing <br>
parrot(voltage=5.0, 'dead')  # non-keyword argument after a keyword argument <br>
parrot(110, voltage=220)     # duplicate value for the same argument <br>
parrot(actor='John Cleese')  # unknown keyword argument <br>
</code>
<p>

    In a function call, keyword arguments must follow positional arguments. All the keyword arguments passed must match one of the arguments accepted by the function (e.g. actor is not a valid argument for the parrot function), and their order is not important. This also includes non-optional arguments (e.g. parrot(voltage=1000) is valid too). No argument may receive a value more than once. </p>
   
</section>
<section class="main-section">
    <header>Special parameters</header>
    <p>By default, arguments may be passed to a Python function either by position or explicitly by keyword. For readability and performance, it makes sense to restrict the way arguments can be passed so that a developer need only look at the function definition to determine if items are passed by position, by position or keyword, or by keyword.</p>
<p>A function definition may look like:</p>
<code>
    <p>def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2): <br>
&emsp;&emsp;&emsp;-----------&emsp;&emsp;&emsp;----------&emsp;&emsp;&emsp;---------- <br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&ensp;|&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;| <br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;| &emsp;  Positional or keyword &emsp;| <br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;       |                     &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;           - Keyword only <br>
&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;-- Positional only</p>
    </code>
    <p>where / and * are optional. If used, these symbols indicate the kind of parameter by how the arguments may be passed to the function: positional-only, positional-or-keyword, and keyword-only. Keyword parameters are also referred to as named parameters.</p>
</section>
<section class="main-section">
    <header>Reference</header>
    <p>Every single Piece of Material is taken from <a href="https://docs.python.org/3/">https://docs.python.org/3/</a></p>
</section>

</main>

<body>

</body>

</html>